## 实现功能



### 简答作业回答

#### 1. **程序错误行为描述**

在正确进入用户态（U态）后，程序尝试执行S态特权指令或访问S态寄存器时，会触发异常并报错。具体行为如下：

- **执行S态特权指令**：
当用户态程序尝试执行诸如`csrw sstatus, t0`等S态特权指令时，CPU会检测到非法指令异常。系统捕获该异常后，通过`__restore`函数返回用户态，同时输出错误信息，如“非法指令错误”或“权限不足”。

- **访问S态寄存器**：
用户态程序若试图读取或写入S态寄存器（例如`sstatus`、`sepc`）时，系统会检测到非法访问，触发访问异常。异常处理程序会通过`__restore`返回用户态，并输出相应的错误提示，如“非法寄存器访问错误”。

- **运行错误测试用例**：
在运行三个错误测试用例（`ch2b_bad_*.rs`）时，程序在尝试执行上述非法操作时，会被操作系统正确捕获并处理，确保系统的稳定性和安全性。测试过程中使用的SBI（Supervisor Binary Interface）版本为**[请根据实际情况填写具体版本号]**。

这些错误行为验证了操作系统在用户态程序试图进行特权操作或非法访问系统资源时，能够有效地捕获并处理异常，防止系统被破坏或进入不稳定状态。

#### 2. **L40：刚进入 `__restore` 时，`a0` 代表了什么值。请指出 `__restore` 的两种使用情景。**

在`__restore`函数刚进入时，`a0`寄存器通常代表系统调用的返回值或异常处理的返回值。具体来说：

- **系统调用返回**：
当用户态程序通过系统调用（如`ecall`指令）请求操作系统服务时，操作系统在处理完系统调用后，会调用`__restore`函数返回用户态。此时，`a0`存储的是系统调用的结果或返回值，供用户态程序继续执行。

- **异常处理返回**：
当发生异常（如中断、非法指令、内存访问错误等）后，异常处理程序处理完毕后，会调用`__restore`函数恢复到用户态。此时，`a0`存储的是异常处理的结果或相关返回信息，供用户态程序进行相应处理或终止。

#### 3. **L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。**

```C++
ld t0, 32*8(sp)
ld t1, 33*8(sp)
ld t2, 2*8(sp)
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
```

- **`sstatus` 寄存器**：

    - **作用**：`sstatus`是超级用户模式（S模式）的状态寄存器，控制和反映CPU的各种特权级状态和中断使能等信息。

    - **意义**：恢复 `sstatus`的值是为了恢复进入用户态前的CPU状态，包括中断使能、特权级等，确保用户态程序在正确的环境下运行。

- **`sepc` 寄存器**：

    - **作用**：`sepc`（Supervisor Exception Program Counter）存储发生异常或中断时的程序计数器地址，即中断或异常发生时程序的下一条指令地址。

    - **意义**：恢复`sepc`的值确保在返回用户态时，程序能够从中断或异常发生的正确位置继续执行。

- **`sscratch` 寄存器**：

    - **作用**：`sscratch`是一个临时寄存器，常用于在陷入超级用户模式时保存用户态的堆栈指针等临时数据。

    - **意义**：恢复`sscratch`的值主要用于保存和恢复用户态的堆栈指针（`sp`），确保用户态程序能够正确访问其堆栈。

这些寄存器的正确恢复对于确保用户态程序能够在预期的状态和位置继续执行至关重要。

#### 4. **L50-L56：为何跳过了 `x2` 和 `x4`？**

```C++
ld x1, 1*8(sp)
ld x3, 3*8(sp)
.set n, 5
.rept 27
   LOAD_GP %n
   .set n, n+1
.endr
```

- **跳过 `x2`（`sp`）**：
`x2`是堆栈指针寄存器（`sp`），在恢复用户态时会通过特殊指令`csrrw sp, sscratch, sp`进行恢复。因此，无需在此处显式加载和保存`x2`。堆栈指针的恢复统一在后续步骤中处理，避免重复操作。

- **跳过 `x4`（`tp`）**：
`x4`是线程指针寄存器（`tp`），通常在用户态程序中不常用，除非进行特定的多线程操作。因此，在恢复用户态时无需特别保存和恢复`x4`，以优化性能和简化寄存器恢复过程。

综上所述，`x2`和`x4`被跳过是因为它们要么通过其他机制（如`sp`的恢复）进行处理，要么在大多数用户态程序中不常用，避免不必要的寄存器保存和恢复操作。

#### 5. **L60：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？**

```C++
csrrw sp, sscratch, sp
```

- **`sp`（堆栈指针）**：

    - **意义**：执行`csrrw sp, sscratch, sp`指令后，`sp`被设置为原先`sscratch`的值，即用户态的堆栈指针。这意味着当前的堆栈指针指向用户态的堆栈，为用户态程序的执行做好准备。

- **`sscratch`**：

    - **意义**：在指令执行后，`sscratch`被设置为原先`sp`的值，即内核态的堆栈指针。这保留了内核态堆栈指针的值，以便在用户态返回后能够正确切换回内核态。

通过交换`sp`和`sscratch`的值，系统实现了从内核态堆栈到用户态堆栈的切换，为用户态程序的执行提供了独立的堆栈空间。

#### 6. **`__restore` 中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？**

状态切换发生在指令`SRET`上：

```C++
sret
```

- **原因**：

    - `sret`指令用于从超级用户模式（S模式）返回到之前的特权级别（通常是用户态）。当执行`SRET`时，CPU根据`sstatus`寄存器中的`SPP`（Previous Privilege）字段恢复到先前的特权级别，并跳转到`sepc`寄存器中存储的程序计数器地址。

    - 在`__restore`函数中，所有必要的寄存器和状态信息已经被恢复到正确的值，包括堆栈指针、程序计数器和状态寄存器。因此，执行`SRET`后，CPU自动切换到用户态，并从用户态程序的正确位置继续执行。

#### 7. **L13：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？**

```C++
csrrw sp, sscratch, sp
```

- **执行前**：

    - `sp`指向内核态的堆栈指针。

    - `sscratch`存储的是用户态的堆栈指针。

- **执行后**：

    - `sp`被设置为`sscratch`的值，即用户态的堆栈指针。这意味着当前的堆栈指针指向用户态的堆栈，为用户态程序的执行提供了正确的堆栈空间。

    - `sscratch`被设置为原先`sp`的值，即内核态的堆栈指针，保留了内核态堆栈指针的值，以便在需要时能够恢复到内核态。

通过这条指令，实现了从内核态堆栈到用户态堆栈的切换，确保用户态程序能够在其独立的堆栈空间中运行，而内核态堆栈则被保留以供后续内核操作使用。

#### 8. **从 U 态进入 S 态是哪一条指令发生的？**

从用户态（U态）进入超级用户态（S态）主要通过`ecall`指令触发系统调用，从而引发陷入（trap）到内核态。具体流程如下：

- **触发指令**：

    - 用户态程序执行`ecall`指令，这是一个环境调用指令，用于请求操作系统提供服务或进行系统调用。

- **执行过程**：

    - 当`ecall`指令被执行时，CPU产生一个系统调用陷入，将当前的程序计数器（`sepc`）和状态寄存器（`sstatus`）等信息保存，并切换到超级用户态（S态）执行相应的系统调用处理程序。

- **示例代码**：

    - 在异常处理程序或系统调用处理函数中，通常会调用`__alltraps`或类似的函数来处理`ecall`产生的陷入，并最终通过`__restore`返回用户态。

因此，从用户态进入超级用户态的关键指令是`ecall`，它触发了特权级的切换，使程序从用户态进入内核态以执行系统调用或异常处理。

# **荣誉准则**

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    > 与同队的师兄讨论了实现思路

1. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    > [https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html](https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html)
参考了一个豆腐大佬的文档

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

